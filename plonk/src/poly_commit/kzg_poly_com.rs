//! KZG polynomial commitment scheme:
//! https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf
//! This polynomial scheme relies on a bilinear map e:G1 x G2 -> Gt,
//! where G1,G2,Gt are cyclic groups of prime order p.
//! Let g1 be a generator of G1 and g2 be a generator of G_2.
//! The operations of the scheme are as follows:
//!
//! setup(n: max polynomial degree)
//!    Pick a random scalar s in Z_p
//!    Compute public_parameter_group_1:= (g1,g1^s,g1^{s^2},...,g1^{s^n})
//!    Compute public_parameter_group_2:= (g2,g2^s)
//!    return (public_parameter_group_1,public_parameter_group_2)
//!
//! commit(P: polynomial)
//!    let P(x) = a0 + a1X + a2X^2 + ...+ a_nX^n
//!    let C := g1^{P(s)} = \pi_{i=0}^n (g_i^{s^i})^{a_i}
//!    return C
//!
//! prove_eval(P:polynomial,x: evaluation point)
//!    Let y=P(x)
//!    Compute Q(X) = (P(X)-P(x))/(X-x)  # if indeed y==P(x) then (X-x)|P(X)-y
//!    return g1^{Q(s)}
//!
//! verify_eval(C: commitment, x: evaluation point, y: evaluation of P on x, proof: proof of evaluation)
//!    The goal of this verification procedure is to check that indeed P(X)-y=Q(X)(X-x) using pairings
//!    Check that e(C/g1^y,g2) == e(proof,g2^s/g2^x)
//!
use crate::poly_commit::{
    errors::PolyComSchemeError,
    field_polynomial::FpPolynomial,
    pcs::{HomomorphicPolyComElem, PolyComScheme, ToBytes},
};
use merlin::Transcript;
use zei_algebra::{
    bls12_381::{BLSPairingEngine, BLSScalar, BLSG1},
    fs,
    prelude::*,
    traits::Pairing,
};

/// KZG commitment scheme about the `Group`.
#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct KZGCommitment<G>(pub G);

impl<'a, G> ToBytes for KZGCommitment<G>
where
    G: Group,
{
    fn to_bytes(&self) -> Vec<u8> {
        self.0.to_compressed_bytes()
    }
}

impl HomomorphicPolyComElem for KZGCommitment<BLSG1> {
    type Scalar = BLSScalar;
    fn get_base() -> Self {
        KZGCommitment(BLSG1::get_base())
    }

    fn get_identity() -> Self {
        KZGCommitment(BLSG1::get_identity())
    }

    fn add(&self, other: &Self) -> Self {
        KZGCommitment(self.0.add(&other.0))
    }

    fn add_assign(&mut self, other: &Self) {
        self.0.add_assign(&other.0)
    }

    fn sub(&self, other: &Self) -> Self {
        KZGCommitment(self.0.sub(&other.0))
    }

    fn sub_assign(&mut self, other: &Self) {
        self.0.sub_assign(&other.0)
    }

    fn mul(&self, exp: &BLSScalar) -> Self {
        KZGCommitment(self.0.mul(exp))
    }

    fn mul_assign(&mut self, exp: &BLSScalar) {
        self.0.mul_assign(&exp)
    }
}

impl<F: Scalar> ToBytes for FpPolynomial<F> {
    fn to_bytes(&self) -> Vec<u8> {
        unimplemented!()
    }
}

impl<F: Scalar> HomomorphicPolyComElem for FpPolynomial<F> {
    type Scalar = F;

    fn get_base() -> Self {
        unimplemented!()
    }

    fn get_identity() -> Self {
        unimplemented!()
    }

    fn add(&self, other: &Self) -> Self {
        self.add(other)
    }

    fn add_assign(&mut self, other: &Self) {
        self.add_assign(other)
    }

    fn sub(&self, other: &Self) -> Self {
        self.sub(other)
    }

    fn sub_assign(&mut self, other: &Self) {
        self.sub_assign(other)
    }

    fn mul(&self, exp: &F) -> Self {
        self.mul_scalar(exp)
    }

    fn mul_assign(&mut self, exp: &F) {
        self.mul_scalar_assign(exp)
    }
}

/// KZG eval proof.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub struct KZGEvalProof<G1>(pub G1);

impl<G: Group> ToBytes for KZGEvalProof<G> {
    fn to_bytes(&self) -> Vec<u8> {
        self.0.to_compressed_bytes()
    }
}

/// KZG commitment scheme about `PairingEngine`.
#[derive(Debug, Serialize, Deserialize)]
pub struct KZGCommitmentScheme<P: Pairing> {
    /// public parameter about G1.
    pub public_parameter_group_1: Vec<P::G1>,
    /// public parameter about G1.
    pub public_parameter_group_2: Vec<P::G2>,
}

impl<P: Pairing> KZGCommitmentScheme<P> {
    /// Create a new instance of a KZG polynomial commitment scheme.
    /// `max_degree` - max degree of the polynomial,
    /// `prng` - pseudo-random generator.
    pub fn new<R: CryptoRng + RngCore>(max_degree: usize, prng: &mut R) -> KZGCommitmentScheme<P> {
        let s = P::ScalarField::random(prng);

        let mut public_parameter_group_1: Vec<P::G1> = Vec::new();

        let mut elem_g1 = P::G1::get_base();

        for _ in 0..=max_degree {
            public_parameter_group_1.push(elem_g1.clone());
            elem_g1 = elem_g1.mul(&s);
        }

        let mut public_parameter_group_2: Vec<P::G2> = Vec::new();
        let elem_g2 = P::G2::get_base();
        public_parameter_group_2.push(elem_g2.clone());
        public_parameter_group_2.push(elem_g2.mul(&s));

        KZGCommitmentScheme {
            public_parameter_group_1,
            public_parameter_group_2,
        }
    }

    /// Get the public parameters from a file.
    /// This file is generated by the executable `zkp-params-utils`
    /// * `filename` - name of the file containing the data of the public parameters
    /// This file must be in the directory `test_data` at the root of this crate.
    pub fn from_file(filename: &str) -> Result<KZGCommitmentScheme<P>> {
        let contents = fs::read(filename);
        if contents.is_err() {
            return Err(eg!(ZeiError::ParameterError));
        }
        let commitment_scheme: Result<KZGCommitmentScheme<P>> =
            bincode::deserialize(&contents.unwrap()).c(d!());
        match commitment_scheme {
            Ok(c) => Ok(c),
            _ => Err(eg!(ZeiError::ParameterError)),
        }
    }

    /// serialize the parameters to unchecked bytes.
    pub fn to_unchecked_bytes(&self) -> Result<Vec<u8>> {
        let mut bytes = vec![];
        let len_1 = self.public_parameter_group_1.len() as u32;
        let len_2 = self.public_parameter_group_2.len() as u32;
        bytes.extend(len_1.to_le_bytes());
        bytes.extend(len_2.to_le_bytes());

        for i in &self.public_parameter_group_1 {
            bytes.extend(i.to_unchecked_bytes());
        }
        for i in &self.public_parameter_group_2 {
            bytes.extend(i.to_unchecked_bytes());
        }
        Ok(bytes)
    }

    /// deserialize the parameters from unchecked bytes.
    pub fn from_unchecked_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() < 8 {
            return Err(eg!(ZeiError::DeserializationError));
        }
        let mut len_1_bytes = [0u8; 4];
        let mut len_2_bytes = [0u8; 4];
        len_1_bytes.copy_from_slice(&bytes[0..4]);
        len_2_bytes.copy_from_slice(&bytes[4..8]);
        let len_1 = u32::from_le_bytes(len_1_bytes) as usize;
        let len_2 = u32::from_le_bytes(len_2_bytes) as usize;
        let n_1 = P::G1::unchecked_size();
        let n_2 = P::G2::unchecked_size();

        let bytes_1 = &bytes[8..];
        let bytes_2 = &bytes[8 + (n_1 * len_1)..];
        let mut p1 = vec![];
        let mut p2 = vec![];

        for i in 0..len_1 {
            p1.push(P::G1::from_unchecked_bytes(
                &bytes_1[n_1 * i..n_1 * (i + 1)],
            )?);
        }

        for i in 0..len_2 {
            p2.push(P::G2::from_unchecked_bytes(
                &bytes_2[n_2 * i..n_2 * (i + 1)],
            )?);
        }

        Ok(Self {
            public_parameter_group_1: p1,
            public_parameter_group_2: p2,
        })
    }
}

/// Define the `KZGCommitmentScheme` by given `BLSPairingEngine`.
pub type KZGCommitmentSchemeBLS = KZGCommitmentScheme<BLSPairingEngine>;

impl<'b> PolyComScheme for KZGCommitmentSchemeBLS {
    type Field = BLSScalar;
    type Commitment = KZGCommitment<BLSG1>;
    type Opening = FpPolynomial<Self::Field>;

    fn max_degree(&self) -> usize {
        self.public_parameter_group_1.len() - 1
    }

    fn commit(
        &self,
        polynomial: FpPolynomial<BLSScalar>,
    ) -> Result<(Self::Commitment, Self::Opening)> {
        let coefs_poly = polynomial.get_coefs_ref();

        let pol_degree = polynomial.degree();

        if pol_degree + 1 > self.public_parameter_group_1.len() {
            return Err(eg!(PolyComSchemeError::DegreeError));
        }

        let coefs_poly_bls_scalar_ref: Vec<&BLSScalar> = coefs_poly.iter().collect();
        let pub_param_group_1_as_ref: Vec<&BLSG1> = self.public_parameter_group_1
            [0..pol_degree + 1]
            .iter()
            .collect();

        let commitment_value = BLSG1::multi_exp_unsafe(
            &coefs_poly_bls_scalar_ref[..],
            &pub_param_group_1_as_ref[..],
        );

        Ok((KZGCommitment(commitment_value), polynomial))
    }

    fn opening(&self, polynomial: &FpPolynomial<Self::Field>) -> Self::Opening {
        (*polynomial).clone()
    }

    fn eval_opening(
        &self,
        opening: &FpPolynomial<Self::Field>,
        point: &Self::Field,
    ) -> Self::Field {
        opening.eval(point)
    }

    fn apply_blind_factors(
        &self,
        commitment: &Self::Commitment,
        blinds: &[Self::Field],
        zeroing_degree: usize,
    ) -> Self::Commitment {
        let mut commitment = commitment.0.clone();
        for (i, blind) in blinds.iter().enumerate() {
            let mut blind = blind.clone();
            commitment = commitment + &(self.public_parameter_group_1[i] * &blind);
            blind = blind.neg();
            commitment = commitment + &(self.public_parameter_group_1[zeroing_degree + i] * &blind);
        }
        KZGCommitment(commitment)
    }

    fn commitment_from_opening(&self, opening: &Self::Opening) -> Self::Commitment {
        let poly = self.polynomial_from_opening_ref(opening);
        let (c, _) = self.commit(poly).unwrap();
        c
    }

    fn polynomial_from_opening_ref(&self, opening: &Self::Opening) -> FpPolynomial<Self::Field> {
        (*opening).clone()
    }

    fn polynomial_from_opening(&self, opening: Self::Opening) -> FpPolynomial<Self::Field> {
        opening
    }

    fn prove(
        &self,
        _transcript: &mut Transcript,
        opening: &FpPolynomial<Self::Field>,
        x: &Self::Field,
        max_degree: usize,
    ) -> Result<Self::Commitment> {
        let polynomial = opening;
        let evaluation = polynomial.eval(x);

        // Compute the proof value
        if polynomial.degree() > max_degree {
            println!(
                "polynomial degree = {}, max_degree = {}",
                polynomial.degree(),
                max_degree
            );
            return Err(eg!(PolyComSchemeError::DegreeError));
        }

        let y = FpPolynomial::from_coefs(vec![evaluation]); // P(x)
        let f_eval_polynomial = polynomial.sub(&y); // P(X)-P(x)

        // Negation must happen in Fq
        let point_neg = x.neg();

        // X-x
        let divisor_polynomial = FpPolynomial::from_coefs(vec![point_neg, Self::Field::one()]);
        let (quotient_polynomial, remainder_polynomial) =
            f_eval_polynomial.div_rem(&divisor_polynomial); // P(X)-P(x) / (X-x)

        if !remainder_polynomial.is_zero() {
            return Err(eg!(PolyComSchemeError::PCSProveEvalError));
        }

        let proof_value = self.commit(quotient_polynomial).unwrap().0;
        Ok(proof_value)
    }

    fn verify(
        &self,
        _transcript: &mut Transcript,
        c: &Self::Commitment,
        _degree: usize,
        x: &Self::Field,
        y: &Self::Field,
        proof: &Self::Commitment,
    ) -> Result<()> {
        let g1_0 = self.public_parameter_group_1[0].clone();
        let g2_0 = self.public_parameter_group_2[0].clone();
        let g2_1 = self.public_parameter_group_2[1].clone();

        let x_minus_point_group_element_group_2 = &g2_1.sub(&g2_0.mul(x));

        // e(g1^{P(X)-P(x)},g2)
        let left_pairing_eval = if y.is_zero() {
            BLSPairingEngine::pairing(&c.0, &g2_0)
        } else {
            BLSPairingEngine::pairing(&c.0.sub(&g1_0.mul(y)), &g2_0)
        };

        // e(g1^{Q(X)},g1^{X-x})
        let right_pairing_eval =
            BLSPairingEngine::pairing(&proof.0, &x_minus_point_group_element_group_2);

        // e(g1^{P(X)-P(x)},g2) == e(g1^{Q(X)},g2^{X-v})
        if left_pairing_eval == right_pairing_eval {
            Ok(())
        } else {
            Err(eg!(PolyComSchemeError::PCSProveEvalError))
        }
    }

    fn batch_verify_diff_points(
        &self,
        _transcript: &mut Transcript,
        c: &[Self::Commitment],
        _degree: usize,
        x: &[Self::Field],
        y: &[Self::Field],
        proof: &[Self::Commitment],
        challenge: &Self::Field,
    ) -> Result<()> {
        assert!(proof.len() > 0);
        assert_eq!(proof.len(), x.len());
        assert_eq!(proof.len(), y.len());
        assert_eq!(proof.len(), c.len());

        let g1_0 = self.public_parameter_group_1[0].clone();
        let g2_0 = self.public_parameter_group_2[0].clone();
        let g2_1 = self.public_parameter_group_2[1].clone();

        let left_second = g2_1;
        let right_second = g2_0;

        let mut left_first = proof[0].0.clone();
        let mut right_first = proof[0].0.mul(&x[0]);
        let mut right_first_val = y[0].clone();
        let mut right_first_comm = c[0].0.clone();

        let mut cur_challenge = challenge.clone();
        for i in 1..proof.len() {
            let new_comm = proof[i].0.mul(&cur_challenge);

            left_first.add_assign(&new_comm);
            right_first.add_assign(&new_comm.mul(&x[i]));
            right_first_val.add_assign(&y[i].mul(&cur_challenge));
            right_first_comm.add_assign(&c[i].0.mul(&cur_challenge));

            cur_challenge.mul_assign(&challenge);
        }
        right_first.sub_assign(&g1_0.mul(&right_first_val));
        right_first.add_assign(&right_first_comm);

        let left_pairing_eval = BLSPairingEngine::pairing(&left_first, &left_second);
        let right_pairing_eval = BLSPairingEngine::pairing(&right_first, &right_second);

        if left_pairing_eval == right_pairing_eval {
            Ok(())
        } else {
            println!("not equal");
            Err(eg!(PolyComSchemeError::PCSProveEvalError))
        }
    }

    fn shrink_to_verifier_only(&self) -> Result<Self> {
        Ok(Self {
            public_parameter_group_1: vec![self.public_parameter_group_1[0].clone()],
            public_parameter_group_2: vec![
                self.public_parameter_group_2[0].clone(),
                self.public_parameter_group_2[1].clone(),
            ],
        })
    }
}

#[cfg(test)]
mod tests_kzg_impl {
    use crate::poly_commit::{
        field_polynomial::FpPolynomial,
        kzg_poly_com::{KZGCommitmentScheme, KZGCommitmentSchemeBLS},
        pcs::{HomomorphicPolyComElem, PolyComScheme},
    };
    use merlin::Transcript;
    use rand_chacha::ChaChaRng;
    use zei_algebra::{
        bls12_381::{BLSPairingEngine, BLSScalar, BLSG1},
        prelude::*,
        traits::Pairing,
    };

    fn _check_public_parameters_generation<P: Pairing>() {
        let param_size = 5;
        let mut prng = ChaChaRng::from_seed([0u8; 32]);
        let kzg_scheme = KZGCommitmentScheme::<P>::new(param_size, &mut prng);
        let g1_power1 = kzg_scheme.public_parameter_group_1[1].clone();
        let g2_power1 = kzg_scheme.public_parameter_group_2[1].clone();

        // Check parameters for G1
        for i in 0..param_size - 1 {
            let elem_first_group_1 = kzg_scheme.public_parameter_group_1[i].clone();
            let elem_next_group_1 = kzg_scheme.public_parameter_group_1[i + 1].clone();
            let elem_next_group_1_target = P::pairing(&elem_next_group_1, &P::G2::get_base());
            let elem_next_group_1_target_recomputed = P::pairing(&elem_first_group_1, &g2_power1);
            assert_eq!(
                elem_next_group_1_target_recomputed,
                elem_next_group_1_target
            );
        }

        // Check parameters for G2
        let elem_first_group_2 = kzg_scheme.public_parameter_group_2[0].clone();
        let elem_second_group_2 = kzg_scheme.public_parameter_group_2[1].clone();
        let elem_next_group_2_target = P::pairing(&P::G1::get_base(), &elem_second_group_2);
        let elem_next_group_2_target_recomputed = P::pairing(&g1_power1, &elem_first_group_2);

        assert_eq!(
            elem_next_group_2_target_recomputed,
            elem_next_group_2_target
        );
    }

    //This test is only for check the size of the CRS which is n + 3
    //it's g1, g2, s[g2] and s[g1],...,s^n[g1]
    fn _generation_of_crs<P: Pairing>() {
        let n = 1 << 5;
        let mut prng = ChaChaRng::from_seed([0u8; 32]);
        let kzg_scheme = KZGCommitmentScheme::<P>::new(n, &mut prng);
        assert_eq!(kzg_scheme.public_parameter_group_1.len(), n + 1);
        assert_eq!(kzg_scheme.public_parameter_group_2.len(), 2);
    }

    #[test]
    fn test_homomorphic_poly_com_elem() {
        let mut prng = ChaChaRng::from_seed([0_u8; 32]);
        let pcs = KZGCommitmentSchemeBLS::new(20, &mut prng);
        type Field = BLSScalar;
        let one = Field::one();
        let two = one.add(&one);
        let three = two.add(&one);
        let four = three.add(&one);
        let six = three.add(&three);
        let eight = six.add(&two);
        let poly1 = FpPolynomial::from_coefs(vec![two, three, six]);

        let (commitment1, poly1) = pcs.commit(poly1).unwrap();

        let poly2 = FpPolynomial::from_coefs(vec![one, eight, four]);

        let (commitment2, poly2) = pcs.commit(poly2).unwrap();

        // Add two polynomials
        let poly_sum = poly1.add(&poly2);
        let (commitment_sum, _) = pcs.commit(poly_sum).unwrap();
        let commitment_sum_computed = commitment1.add(&commitment2);
        assert_eq!(commitment_sum, commitment_sum_computed);

        // Multiplying all the coefficients of a polynomial by some value
        let exponent = four.add(&one);
        let poly1_mult_5 = poly1.mul_scalar(&exponent);
        let (commitment_poly1_mult_5, _) = pcs.commit(poly1_mult_5).unwrap();
        let commitment_poly1_mult_5_hom = commitment1.mul(&exponent);
        assert_eq!(commitment_poly1_mult_5, commitment_poly1_mult_5_hom);
    }

    #[test]
    fn test_public_parameters() {
        _check_public_parameters_generation::<BLSPairingEngine>();
    }

    #[test]
    fn test_generation_of_crs() {
        _generation_of_crs::<BLSPairingEngine>();
    }

    #[test]
    fn test_commit() {
        let mut prng = ChaChaRng::from_seed([0_u8; 32]);
        let pcs = KZGCommitmentSchemeBLS::new(10, &mut prng);
        type Field = BLSScalar;
        let one = Field::one();
        let two = one.add(&one);
        let three = two.add(&one);
        let six = three.add(&three);

        let fq_poly = FpPolynomial::from_coefs(vec![two, three, six]);
        let (commitment, open) = pcs.commit(fq_poly).unwrap();

        let coefs_poly_blsscalar = open.get_coefs_ref().iter().collect_vec();
        let mut expected_committed_value = BLSG1::get_identity();

        // Doing the multiexp by hand
        for (i, coef) in coefs_poly_blsscalar.iter().enumerate() {
            let g_i = pcs.public_parameter_group_1[i].clone();
            expected_committed_value = expected_committed_value.add(&g_i.mul(&coef));
        }
        assert_eq!(expected_committed_value, commitment.0);
    }

    #[test]
    fn test_eval() {
        let mut prng = ChaChaRng::from_seed([0_u8; 32]);
        let pcs = KZGCommitmentSchemeBLS::new(10, &mut prng);
        type Field = BLSScalar;
        let one = Field::one();
        let two = one.add(&one);
        let three = two.add(&one);
        let four = three.add(&one);
        let six = three.add(&three);
        let seven = six.add(&one);
        let fq_poly = FpPolynomial::from_coefs(vec![one, two, four]);
        let point = one;
        let max_degree = fq_poly.degree();

        let mut not_needed_transcript = Transcript::new(b"transcript_not_needed");

        let degree = fq_poly.degree();
        let (commitment_value, opening) = pcs.commit(fq_poly).unwrap();

        // Check that an error is returned if the degree of the polynomial exceeds the maximum degree.
        let wrong_max_degree = 1;
        let res = pcs.prove(
            &mut not_needed_transcript,
            &opening,
            &point,
            wrong_max_degree,
        );
        assert!(res.is_err());

        let proof = pcs
            .prove(&mut not_needed_transcript, &opening, &point, max_degree)
            .unwrap();

        let res = pcs.verify(
            &mut not_needed_transcript,
            &commitment_value,
            degree,
            &point,
            &seven,
            &proof,
        );
        pnk!(res);

        let new_pcs = pcs.shrink_to_verifier_only().unwrap();
        let res = new_pcs.verify(
            &mut not_needed_transcript,
            &commitment_value,
            degree,
            &point,
            &seven,
            &proof,
        );
        pnk!(res);

        let wrong_value_verif = one;
        let wrong_value_verif = pcs.verify(
            &mut not_needed_transcript,
            &commitment_value,
            degree,
            &point,
            &wrong_value_verif,
            &proof,
        );
        assert!(wrong_value_verif.is_err());
    }
}
