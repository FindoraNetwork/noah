use crate::microsalt::stream;
use crate::microsalt::onetimeauth;

//Length of key
pub const SECRETBOX_KEY_LEN : usize = 32;
//Length of nonce
pub const SECRETBOX_NONCE_LEN : usize = 24;

pub type SecretboxKey = [u8;SECRETBOX_KEY_LEN];
pub type SecretboxNonce = [u8;SECRETBOX_NONCE_LEN];

//https://github.com/golang/crypto/blob/master/nacl/secretbox/secretbox.go
// Seal appends an encrypted and authenticated copy of message to out, which
// must not overlap message. The key and nonce pair must be unique for each
// distinct message and the output will be Overhead bytes longer than message.
pub fn secretbox(out: &mut [u8], message: &[u8], nonce: &SecretboxNonce, key: &SecretboxKey) -> Result<(),()> {
    assert_eq!(out.len(), message.len()); //Handle errors here 
    /* first 32 bytes must be zero */
    assert_eq!(&message[0..32], &[0u8;32]);

    stream::xsalsa20::stream_xor(out,message,nonce,key);
    // The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
	// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
    // keystream as a side effect.
    let mut o = [0u8;16]; {
        /* XXX: we avoid aliasing to make rust happy at the cost of an extra copy via @o */
        let (c_k, c_m) = out.split_at(32);
        onetimeauth::poly1305::onetimeauth(&mut o, c_m, index_fixed!(&c_k;..32));
    }

    *index_fixed!(&mut out[16..32];..16) = o;
    *index_fixed!(&mut out;..16) = [0u8;16];

    Ok(())
}

/*
 * c: &[u8:d]
 */
pub fn secretbox_open(m: &mut [u8], c: &[u8], nonce: &SecretboxNonce, key: &SecretboxKey) -> bool {
    assert_eq!(m.len(), c.len());
    if c.len() < 32 {
        return true;
    }
    let mut x = [0u8; 32];
    stream::xsalsa20::stream(&mut x, nonce, key);

    if !onetimeauth::poly1305::onetimeauth_verify(index_fixed!(&c[16..];..16), &c[32..], &x) { //
        return true; //HANLDE ERROR HERE MORE ERGONOMICALLY
    }

    stream::xsalsa20::stream_xor(m,c, nonce, key);
    for i in 0..32 {
        m[i] = 0;
    }
    false
}